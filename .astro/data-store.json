[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.2.3","content-config-digest","2844f712b0ac01ca","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://jesfer.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"restful-api",{"id":11,"data":13,"body":18,"filePath":19,"digest":20,"rendered":21},{"title":14,"description":15,"pubDate":16,"heroImage":17},"Principales conceptos de las API RESTful","Un repaso sobre que tener en cuenta al momento de construir una API RESTful",["Date","2025-02-04T05:00:00.000Z"],"/image.png","Las API REST descansan sobre la arquitectura de Cliente-Servidor, donde se separan las responsabilidades de almacenamiento datos y lógica de negocio del cliente, proporcionando a este, solo lo necesario. Dicha separación permite que una API pueda ser escrita en diferentes lenguajes, sin importar el lenguaje del cliente, siempre y cuando se respete el protocolo de comunicación (HTTP, JSON, etc.).\n\nEn resumen, lo que sucede dentro de la API, como la implementación, lenguaje, lógica, esquema de base de datos, tecnologías, bibliotecas, etc. debe ser totalmente transparentes al cliente.\n\nLa filosofía de REST de basa principalmente en unos principios, los cuales se muestran a continuación.\n\n**Diseño en torno a recursos**: Los recursos son cualquier tipo de objeto, dato o servicio que puede ser accedido por el cliente. Cada recurso debe poder ser accedido mediante un identificador, el cual se le conoce como URI.\n\n**Utilizan una interfaz uniforme**: Es decir, un esquema que permita desacoplar el cliente del servicio. En el caso de API HTTP, se utilizan los verbos tales como: GET, POST, PUT, PATCH, DELETE.\n\n**Sin estado**: Quiere decir que las peticiones deben ser independientes y pueden producirse en cualquier orden. La información se almacena en los propios recursos, es decir, cuando un cliente obtiene una representación de un recurso, este debe contener la información suficiente para poder manipular el recurso.\n\n**Manejadas mediante enlaces hipermedia**: Estos enlaces deben estar contenidos en la propia representación y deben permitir navegar por las distintas interfaces asociadas.\n\nUna ventaja adicional es que, si se cumplen con los principios (en especial, sin estado), los datos resultantes de un petición pueden ser almacenados en caché, permitiendo un ahorro significativo en los recursos (computación, ancho de banda, latencia, etc).\n\nLas claves para una buena API REST, son las siguientes:\n\n- Fácil de aprender.\n- Fácil de usar.\n- Difícil de usar mal.\n- Código fácil de leer y mantener.\n- Suficientemente potente para cumplir con los requerimientos.\n- Fácil de extender.\n- Adecuado para uso público.\n\n#### Modelo de madurez de las API REST\n\nPropuesto en 2008 por Leonard Richardson, incluye los siguientes niveles:\n\n- _Nivel 0_: Se define una URI, y todas las peticiones son POST.\n- _Nivel 1_: Se crean URIs separadas para cada recurso individual.\n- _Nivel 2_: Se usan métodos HTTP para definir las operaciones sobre los recursos.\n- _Nivel 3_: Se usa hipermedia (HATEOAS).\n\nLa mayorá de APIs solo llegan al _Nivel 2_.\n\n### Recursos\n\nComo se mencionó anteriormente, los recursos son una de las bases fundamentales en el diseño de una API RESTful. En este contexto, un recurso puede representarse como una entidad específica o una colección de entidades. Por ejemplo, `users` puede referirse a una lista de usuarios disponibles en la API.\n\nCada recurso debe ser identificado de manera única mediante una URI (Uniform Resource Identifier), lo que permite su acceso a través de métodos HTTP. Por ejemplo, si un cliente necesita obtener información de todos los usuarios, podría acceder al recurso mediante una URI como `http://jesfer.com/api/users`. Para información de un usuario específico, el recurso asociado podría ser identificado como `http://jesfer.com/api/users/{id}`, donde `{id}` representa un identificador único de usuario.\n\n> _Como recomendación, los identificadores deben ser claros y suficientemente descriptivos. En el caso de entidades, se sugiere utilizar sustantivos en plural para representar colecciones de forma intuitiva y coherente._\n\nAunque los recursos pueden representarse como entidades, no es necesario que reflejen exactamente el esquema de la base de datos. De hecho, esta práctica suele ser poco recomendada y, siempre que sea posible, debería evitarse. Y es que, en casos reales será necesario obtener datos de distintas tablas y servirlos mediante un único recurso; de hecho, para casos como este, una muy buena opción es el patrón **Data Mapper**.\n\n### Endpoints anidados\n\nCuando hablamos de endpoints anidados nos referimos a las URIs mediante las cuales obtenemos los recursos de la API, sin embargo, cuando existen relaciones entre entidades podemos representar dichas relaciones mediante un anidamiento. A continuación, un ejemplo.\n\n```json\n/companies/{companyId}/departments/{departmentId}/employees\n```\n\n> _En el ejemplo se muestra una URI que permite obtener empleados, pero pasando por sus relaciones adyacentes; es decir, un empleado de un departamento especifico que a su vez pertenece a una compañía específica._\n\nEn realidad, no existen reglas que determine la forma que deben tener los endpoints y queda a criterio de cada desarrollador adoptar las buenas prácticas según el caso especifico al que se enfrenten.\n\nPor ello, diferentes endpoints pueden obtener la misma data, como se muestra a continuación.\n\n```json\n//El hecho de que los empleados sean accesibles en el departamento:\ncompany/{companyid}/department/{departmentid}/employees\n\n//No significa que no puedan ser accesibles también bajo compañía:\ncompany/{companyid}/employees\n```\n\nSegún Microsoft, es tentador crear URIs anidadas como `/customers/1/orders/99/products`, pero que, en sistemas complejos, puede no ser del todo recomendable. Este anidamiento es difícil de mantener y es poco flexible si las relaciones entre entidades cambian en el futuro.\n\nUna vez se tiene la referencia a un recurso, debería ser posible utilizar dicha referencia para encontrar elementos relacionados con ese recurso. La consulta anterior puede sustituirse por la URI `/customers/1/orders` para encontrar todos los pedidos del cliente 1 y, a continuación, `/orders/99/products` para encontrar los productos de este pedido.\n\n> _Es preferible evitar un anidamiento profundo de recursos en las URIs, ya que un mayor nivel de anidamiento puede hacer las consultas más complicadas y afectar el rendimiento de la API. En lugar de crear URIs con anidamientos excesivos, se recomienda realizar consultas adicionales para obtener la información necesaria. En el ejemplo se muestra un anidamiento de nivel 2, lo cual podría no ser ideal dependiendo del caso._\n\n### Carga y diseño\n\nCuando un cliente realiza una petición a nuestra API, esta genera una carga en el sistema. A medida que aumenta el número de peticiones, dicha carga también se incrementa. Por este motivo, es importante evitar exponer una excesiva cantidad de recursos muy pequeños que obliguen a los clientes a realizar múltiples consultas innecesarias. En su lugar, es preferible desnormalizar los datos y combinar la información en recursos más grandes, tal como se menciona en apartado de _Recursos_.\n\nNo obstante, crear recursos excesivamente grandes con información irrelevante introduce otro problema: aumenta la latencia y el consumo de ancho de banda.\n\n> _Lo ideal es encontrar un equilibrio, creando recursos que ofrezcan al cliente solo la información estrictamente necesaria. En este sentido, es preferible realizar unas pocas consultas adicionales._\n\n### Entidades anidadas\n\nRecordemos las principales relaciones entre entidades:\n\n- Many to Many\n- Many to One\n- One to One\n\nAhora, se presentan algunas formas de como trabajar con entidades anidadas.\n\n##### Incluir las relaciones en las respuestas\n\nLa respuesta incluye los datos propios de la entidad, así como los de las relaciones subyacentes.\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Entity\",\n  \"description\": \"Principal entity\",\n  \"relationships\": [\n    {\n      \"id\": 12,\n      \"name\": \"Relationship entity\",\n      \"description\": \"Relationship of principal entity\"\n    }\n  ]\n}\n```\n\n> _Como se puede apreciar en el ejemplo, se incluye la totalidad de los datos junto con las relaciones asociadas_\n\n**Pros**\n\n- Implementación simple\n- Ideal para pocas entidades con pocas columnas.\n\n**Contras**\n\n- Poco eficiente, en especial para grandes cantidades de datos.\n- Puede mostrar información sensible.\n- Se debe personalizar el esquema.\n\n##### Incluir información parcial\n\nLa respuesta incluye solo datos parciales o específicos.\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Entity\",\n  \"relationships\": [\n    {\n      \"id\": 12,\n      \"name\": \"Relationship entity\"\n    }\n  ]\n}\n```\n\n> _A diferencia del ejemplo anterior el campo `description` no se encuentra presente en el esquema, es decir, las columnas se incluyen parcialmente._\n\n**Pros**\n\n- Solo muestra la información necesaria.\n- Ideal si se solo de debe servir a un único frontend con datos muy específicos.\n\n**Contras**\n\n- Respuestas no estandarizadas.\n- Se debe especificar un nuevo esquema.\n\n##### Entidades poco profundas\n\nPor lo general, se incluyen únicamente los `id` de las entidades asociadas, para que sea el cliente quien consulte por su cuenta los datos completos de dichas relaciones.\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Entity\",\n  \"description\": \"Principal entity\",\n  \"relationships\": [12, 13, 14, 15]\n}\n```\n\n> \\_Como se muestra, solo se incluyen los `id` de las entidades relacionadas para que el frontend se encargue del fetching.\n\n**Pros**\n\n- Entidades genéricas (dado que se mantiene el esquema casi original)\n- Reduce el tamaño de la respuesta.\n- Simplifica el diseño de la API.\n\n**Contras**\n\n- Requiere peticiones adicionales, por consiguiente tiempos adicionales.\n\n> _Por lo general, es recomendable incluir únicamente los `id` de las entidades asociadas, dejando que el cliente realice consultas adicionales para obtener los datos completos de dichas relaciones. Este enfoque reduce el tamaño de la respuesta y simplifica el diseño de la API._\n\n### Semántica HTTP\n\nEs importante que al implementar una API RESTFul, se considere el uso de los adecuados métodos HTTP, dado que permiten una interactuar de manera consistente y predecible con los recursos.\n\n**GET**: Recupera la representación de un recurso, cuando la respuesta es satisfactoria por lo general se retorna un código de estado 200 (OK), sin embargo, cuando no se pudo entrar el recurso el código correspondiente es un 400 (NOT FOUND).\n\n**POST**: Crea un nuevo recurso o activa una determinada operación. Cuando se emplea para crear un recurso nuevo, el código devuelto será un 201 (CREATED). El cuerpo de la respuesta incluye la representación de recurso creado y su ubicación se muestra en la cabecera `Location`. Cuando se ejecutan operaciones, la respuesta de éxito puede ser un código 200 (OK) e incluir el resultado de la operación en el cuerpo de la respuesta, pero si no hay ningún resultado que devolver el código puede ser un 204 (NO CONTENT). Si el cliente envía datos no validos en la solicitud el servido debe devolver un código de estado 400 (BAD REQUEST) y en el cuerpo de la respuesta se puede incluir información adicional sobre el error.\n\n**PUT**: Crea o reemplaza un recurso especifico. Si se crea un nuevo recurso, devuelve un 201 (CREATED), pero si actualiza un recurso existente, devuelve un código 200 (OK) O 204 (NO CONTENT). En caso ocurra un problema con la actualización, es posible devolver un código 409 (CONFLICT). La solicitud debe especificar la URI del recurso y el cuerpo los detalles del recurso a modificar.\n\n**PATCH**: Actualiza parcialmente un recurso específico. A pesar que la especificación del método PUT no indica un formato correcto para este tipo de solicitudes, uno bastante común es que en el cuerpo de la petición, la información parche tiene el misma estructura del recurso original, sin embargo, solo incluye un subconjunto de campos que deben ser actualizados.\n\n**DELETE**: Elimina un recurso especificado. Cuando la eliminación se realiza de manera correcta el servidor debe devolver un código de estado 204 (NO CONTENT), indicando que el proceso ha sido exitoso, pero sin contenido en el cuerpo de la respuesta. Si el recurso a eliminar no existe, se pude devolver un 404 (NOT FOUND).\n\nSiempre que el cuerpo de una respuesta correcta esté vacío, el código de estado podrá ser un 204 (NO CONTENT), como por ejemplo en una búsqueda de la cual no se encuentran resultados.\n\nAdemás de los métodos mencionados, el protocolo HTTP especifica que los formatos de datos se especifican mediante el uso de tipos de medio, conocidos como MIME types. Para daros no binarios, por lo general se emplea JSON (media type = `aplication/json`), y esta información se debe incluir en el encabezado `Content-Type` tanto de la solicitud como de la respuesta, lo cual indica el formato de la representación. Si el servidor recibe un MIME type que no se puede admitir, debe devolver un código de respuesta 415 (UNSUPPORTED MEDIA TYPE).\n\n### Navegación entre recursos\n\nLa filosofía REST establece que es posible navegar por todos los recursos de una API sin necesidad de conocer previamente su estructura o esquema. Para lograrlo, cada respuesta a una solicitud, como un **GET**, debe incluir toda la información necesaria para que el cliente pueda descubrir y acceder a los recursos relacionados. Esto se logra mediante la inclusión de **hipervínculos** dentro de la representación de los recursos, así como las operaciones disponibles para interactuar con ellos.\n\nEste principio fundamental se denomina **HATEOAS** (Hypertext as the Engine of Application State) y garantiza que la interacción con la API sea autodescriptiva y dinámica. En otras palabras, el cliente puede explorar y consumir los recursos siguiendo los enlaces proporcionados, sin requerir conocimientos adicionales más allá del punto de entrada inicial.\n\nPor ejemplo, al solicitar información sobre un recurso específico, como un usuario, la respuesta podría incluir enlaces relacionados para acceder a otros recursos como los pedidos realizados por ese usuario o su perfil completo. Además, estos hipervínculos podrían especificar las acciones permitidas, como editar, eliminar o añadir un nuevo recurso.\n\nEste enfoque mejora la escalabilidad y la flexibilidad de las APIs RESTful, ya que facilita la evolución de la API y minimiza la dependencia del cliente en cambios de implementación específicos.\n\n### Referencias\n\n> 1. https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design\n> 2. https://medium.com/@bourgeoistomas/nested-entities-in-your-api-rest-response-best-practices-and-trade-offs-81260ec49b90\n> 3. https://stackoverflow.com/questions/20951419/what-are-best-practices-for-rest-nested-resources\n> 4. https://www.moesif.com/blog/api-guide/getting-started-with-apis/#core-principles-of-restful-api\n> 5. https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Sub-and-Nested-Resources/\n> 6. https://martinfowler.com/articles/richardsonMaturityModel.html\n> 7. https://github.com/microsoft/api-guidelines/blob/vNext/graph/articles/collections.md","src/content/blog/restful-api.md","40ca24311f4d5a09",{"html":22,"metadata":23},"\u003Cp>Las API REST descansan sobre la arquitectura de Cliente-Servidor, donde se separan las responsabilidades de almacenamiento datos y lógica de negocio del cliente, proporcionando a este, solo lo necesario. Dicha separación permite que una API pueda ser escrita en diferentes lenguajes, sin importar el lenguaje del cliente, siempre y cuando se respete el protocolo de comunicación (HTTP, JSON, etc.).\u003C/p>\n\u003Cp>En resumen, lo que sucede dentro de la API, como la implementación, lenguaje, lógica, esquema de base de datos, tecnologías, bibliotecas, etc. debe ser totalmente transparentes al cliente.\u003C/p>\n\u003Cp>La filosofía de REST de basa principalmente en unos principios, los cuales se muestran a continuación.\u003C/p>\n\u003Cp>\u003Cstrong>Diseño en torno a recursos\u003C/strong>: Los recursos son cualquier tipo de objeto, dato o servicio que puede ser accedido por el cliente. Cada recurso debe poder ser accedido mediante un identificador, el cual se le conoce como URI.\u003C/p>\n\u003Cp>\u003Cstrong>Utilizan una interfaz uniforme\u003C/strong>: Es decir, un esquema que permita desacoplar el cliente del servicio. En el caso de API HTTP, se utilizan los verbos tales como: GET, POST, PUT, PATCH, DELETE.\u003C/p>\n\u003Cp>\u003Cstrong>Sin estado\u003C/strong>: Quiere decir que las peticiones deben ser independientes y pueden producirse en cualquier orden. La información se almacena en los propios recursos, es decir, cuando un cliente obtiene una representación de un recurso, este debe contener la información suficiente para poder manipular el recurso.\u003C/p>\n\u003Cp>\u003Cstrong>Manejadas mediante enlaces hipermedia\u003C/strong>: Estos enlaces deben estar contenidos en la propia representación y deben permitir navegar por las distintas interfaces asociadas.\u003C/p>\n\u003Cp>Una ventaja adicional es que, si se cumplen con los principios (en especial, sin estado), los datos resultantes de un petición pueden ser almacenados en caché, permitiendo un ahorro significativo en los recursos (computación, ancho de banda, latencia, etc).\u003C/p>\n\u003Cp>Las claves para una buena API REST, son las siguientes:\u003C/p>\n\u003Cul>\n\u003Cli>Fácil de aprender.\u003C/li>\n\u003Cli>Fácil de usar.\u003C/li>\n\u003Cli>Difícil de usar mal.\u003C/li>\n\u003Cli>Código fácil de leer y mantener.\u003C/li>\n\u003Cli>Suficientemente potente para cumplir con los requerimientos.\u003C/li>\n\u003Cli>Fácil de extender.\u003C/li>\n\u003Cli>Adecuado para uso público.\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"modelo-de-madurez-de-las-api-rest\">Modelo de madurez de las API REST\u003C/h4>\n\u003Cp>Propuesto en 2008 por Leonard Richardson, incluye los siguientes niveles:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cem>Nivel 0\u003C/em>: Se define una URI, y todas las peticiones son POST.\u003C/li>\n\u003Cli>\u003Cem>Nivel 1\u003C/em>: Se crean URIs separadas para cada recurso individual.\u003C/li>\n\u003Cli>\u003Cem>Nivel 2\u003C/em>: Se usan métodos HTTP para definir las operaciones sobre los recursos.\u003C/li>\n\u003Cli>\u003Cem>Nivel 3\u003C/em>: Se usa hipermedia (HATEOAS).\u003C/li>\n\u003C/ul>\n\u003Cp>La mayorá de APIs solo llegan al \u003Cem>Nivel 2\u003C/em>.\u003C/p>\n\u003Ch3 id=\"recursos\">Recursos\u003C/h3>\n\u003Cp>Como se mencionó anteriormente, los recursos son una de las bases fundamentales en el diseño de una API RESTful. En este contexto, un recurso puede representarse como una entidad específica o una colección de entidades. Por ejemplo, \u003Ccode>users\u003C/code> puede referirse a una lista de usuarios disponibles en la API.\u003C/p>\n\u003Cp>Cada recurso debe ser identificado de manera única mediante una URI (Uniform Resource Identifier), lo que permite su acceso a través de métodos HTTP. Por ejemplo, si un cliente necesita obtener información de todos los usuarios, podría acceder al recurso mediante una URI como \u003Ccode>http://jesfer.com/api/users\u003C/code>. Para información de un usuario específico, el recurso asociado podría ser identificado como \u003Ccode>http://jesfer.com/api/users/{id}\u003C/code>, donde \u003Ccode>{id}\u003C/code> representa un identificador único de usuario.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Cem>Como recomendación, los identificadores deben ser claros y suficientemente descriptivos. En el caso de entidades, se sugiere utilizar sustantivos en plural para representar colecciones de forma intuitiva y coherente.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Cp>Aunque los recursos pueden representarse como entidades, no es necesario que reflejen exactamente el esquema de la base de datos. De hecho, esta práctica suele ser poco recomendada y, siempre que sea posible, debería evitarse. Y es que, en casos reales será necesario obtener datos de distintas tablas y servirlos mediante un único recurso; de hecho, para casos como este, una muy buena opción es el patrón \u003Cstrong>Data Mapper\u003C/strong>.\u003C/p>\n\u003Ch3 id=\"endpoints-anidados\">Endpoints anidados\u003C/h3>\n\u003Cp>Cuando hablamos de endpoints anidados nos referimos a las URIs mediante las cuales obtenemos los recursos de la API, sin embargo, cuando existen relaciones entre entidades podemos representar dichas relaciones mediante un anidamiento. A continuación, un ejemplo.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">/companies/{\u003C/span>\u003Cspan style=\"color:#FDAEB7;font-style:italic\">companyId\u003C/span>\u003Cspan style=\"color:#E1E4E8\">}/departments/{\u003C/span>\u003Cspan style=\"color:#FDAEB7;font-style:italic\">departmentId\u003C/span>\u003Cspan style=\"color:#E1E4E8\">}/employees\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cblockquote>\n\u003Cp>\u003Cem>En el ejemplo se muestra una URI que permite obtener empleados, pero pasando por sus relaciones adyacentes; es decir, un empleado de un departamento especifico que a su vez pertenece a una compañía específica.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Cp>En realidad, no existen reglas que determine la forma que deben tener los endpoints y queda a criterio de cada desarrollador adoptar las buenas prácticas según el caso especifico al que se enfrenten.\u003C/p>\n\u003Cp>Por ello, diferentes endpoints pueden obtener la misma data, como se muestra a continuación.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">//El hecho de que los empleados sean accesibles en el departamento:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">company/{\u003C/span>\u003Cspan style=\"color:#FDAEB7;font-style:italic\">companyid\u003C/span>\u003Cspan style=\"color:#E1E4E8\">}/department/{\u003C/span>\u003Cspan style=\"color:#FDAEB7;font-style:italic\">departmentid\u003C/span>\u003Cspan style=\"color:#E1E4E8\">}/employees\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#6A737D\">//No significa que no puedan ser accesibles también bajo compañía:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">company/{\u003C/span>\u003Cspan style=\"color:#FDAEB7;font-style:italic\">companyid\u003C/span>\u003Cspan style=\"color:#E1E4E8\">}/employees\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Según Microsoft, es tentador crear URIs anidadas como \u003Ccode>/customers/1/orders/99/products\u003C/code>, pero que, en sistemas complejos, puede no ser del todo recomendable. Este anidamiento es difícil de mantener y es poco flexible si las relaciones entre entidades cambian en el futuro.\u003C/p>\n\u003Cp>Una vez se tiene la referencia a un recurso, debería ser posible utilizar dicha referencia para encontrar elementos relacionados con ese recurso. La consulta anterior puede sustituirse por la URI \u003Ccode>/customers/1/orders\u003C/code> para encontrar todos los pedidos del cliente 1 y, a continuación, \u003Ccode>/orders/99/products\u003C/code> para encontrar los productos de este pedido.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Cem>Es preferible evitar un anidamiento profundo de recursos en las URIs, ya que un mayor nivel de anidamiento puede hacer las consultas más complicadas y afectar el rendimiento de la API. En lugar de crear URIs con anidamientos excesivos, se recomienda realizar consultas adicionales para obtener la información necesaria. En el ejemplo se muestra un anidamiento de nivel 2, lo cual podría no ser ideal dependiendo del caso.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Ch3 id=\"carga-y-diseño\">Carga y diseño\u003C/h3>\n\u003Cp>Cuando un cliente realiza una petición a nuestra API, esta genera una carga en el sistema. A medida que aumenta el número de peticiones, dicha carga también se incrementa. Por este motivo, es importante evitar exponer una excesiva cantidad de recursos muy pequeños que obliguen a los clientes a realizar múltiples consultas innecesarias. En su lugar, es preferible desnormalizar los datos y combinar la información en recursos más grandes, tal como se menciona en apartado de \u003Cem>Recursos\u003C/em>.\u003C/p>\n\u003Cp>No obstante, crear recursos excesivamente grandes con información irrelevante introduce otro problema: aumenta la latencia y el consumo de ancho de banda.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Cem>Lo ideal es encontrar un equilibrio, creando recursos que ofrezcan al cliente solo la información estrictamente necesaria. En este sentido, es preferible realizar unas pocas consultas adicionales.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Ch3 id=\"entidades-anidadas\">Entidades anidadas\u003C/h3>\n\u003Cp>Recordemos las principales relaciones entre entidades:\u003C/p>\n\u003Cul>\n\u003Cli>Many to Many\u003C/li>\n\u003Cli>Many to One\u003C/li>\n\u003Cli>One to One\u003C/li>\n\u003C/ul>\n\u003Cp>Ahora, se presentan algunas formas de como trabajar con entidades anidadas.\u003C/p>\n\u003Ch5 id=\"incluir-las-relaciones-en-las-respuestas\">Incluir las relaciones en las respuestas\u003C/h5>\n\u003Cp>La respuesta incluye los datos propios de la entidad, así como los de las relaciones subyacentes.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">{\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"id\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"description\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Principal entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"relationships\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: [\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">      \"id\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">12\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">      \"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Relationship entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">      \"description\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Relationship of principal entity\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  ]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">}\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cblockquote>\n\u003Cp>\u003Cem>Como se puede apreciar en el ejemplo, se incluye la totalidad de los datos junto con las relaciones asociadas\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Cp>\u003Cstrong>Pros\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Implementación simple\u003C/li>\n\u003Cli>Ideal para pocas entidades con pocas columnas.\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Contras\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Poco eficiente, en especial para grandes cantidades de datos.\u003C/li>\n\u003Cli>Puede mostrar información sensible.\u003C/li>\n\u003Cli>Se debe personalizar el esquema.\u003C/li>\n\u003C/ul>\n\u003Ch5 id=\"incluir-información-parcial\">Incluir información parcial\u003C/h5>\n\u003Cp>La respuesta incluye solo datos parciales o específicos.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">{\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"id\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"relationships\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: [\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">      \"id\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">12\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">      \"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Relationship entity\"\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">  ]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">}\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cblockquote>\n\u003Cp>\u003Cem>A diferencia del ejemplo anterior el campo \u003Ccode>description\u003C/code> no se encuentra presente en el esquema, es decir, las columnas se incluyen parcialmente.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Cp>\u003Cstrong>Pros\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Solo muestra la información necesaria.\u003C/li>\n\u003Cli>Ideal si se solo de debe servir a un único frontend con datos muy específicos.\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Contras\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Respuestas no estandarizadas.\u003C/li>\n\u003Cli>Se debe especificar un nuevo esquema.\u003C/li>\n\u003C/ul>\n\u003Ch5 id=\"entidades-poco-profundas\">Entidades poco profundas\u003C/h5>\n\u003Cp>Por lo general, se incluyen únicamente los \u003Ccode>id\u003C/code> de las entidades asociadas, para que sea el cliente quien consulte por su cuenta los datos completos de dichas relaciones.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">{\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"id\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"description\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Principal entity\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">,\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">  \"relationships\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: [\u003C/span>\u003Cspan style=\"color:#79B8FF\">12\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">13\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">14\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">15\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">}\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cblockquote>\n\u003Cp>_Como se muestra, solo se incluyen los \u003Ccode>id\u003C/code> de las entidades relacionadas para que el frontend se encargue del fetching.\u003C/p>\n\u003C/blockquote>\n\u003Cp>\u003Cstrong>Pros\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Entidades genéricas (dado que se mantiene el esquema casi original)\u003C/li>\n\u003Cli>Reduce el tamaño de la respuesta.\u003C/li>\n\u003Cli>Simplifica el diseño de la API.\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Contras\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Requiere peticiones adicionales, por consiguiente tiempos adicionales.\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>\u003Cem>Por lo general, es recomendable incluir únicamente los \u003Ccode>id\u003C/code> de las entidades asociadas, dejando que el cliente realice consultas adicionales para obtener los datos completos de dichas relaciones. Este enfoque reduce el tamaño de la respuesta y simplifica el diseño de la API.\u003C/em>\u003C/p>\n\u003C/blockquote>\n\u003Ch3 id=\"semántica-http\">Semántica HTTP\u003C/h3>\n\u003Cp>Es importante que al implementar una API RESTFul, se considere el uso de los adecuados métodos HTTP, dado que permiten una interactuar de manera consistente y predecible con los recursos.\u003C/p>\n\u003Cp>\u003Cstrong>GET\u003C/strong>: Recupera la representación de un recurso, cuando la respuesta es satisfactoria por lo general se retorna un código de estado 200 (OK), sin embargo, cuando no se pudo entrar el recurso el código correspondiente es un 400 (NOT FOUND).\u003C/p>\n\u003Cp>\u003Cstrong>POST\u003C/strong>: Crea un nuevo recurso o activa una determinada operación. Cuando se emplea para crear un recurso nuevo, el código devuelto será un 201 (CREATED). El cuerpo de la respuesta incluye la representación de recurso creado y su ubicación se muestra en la cabecera \u003Ccode>Location\u003C/code>. Cuando se ejecutan operaciones, la respuesta de éxito puede ser un código 200 (OK) e incluir el resultado de la operación en el cuerpo de la respuesta, pero si no hay ningún resultado que devolver el código puede ser un 204 (NO CONTENT). Si el cliente envía datos no validos en la solicitud el servido debe devolver un código de estado 400 (BAD REQUEST) y en el cuerpo de la respuesta se puede incluir información adicional sobre el error.\u003C/p>\n\u003Cp>\u003Cstrong>PUT\u003C/strong>: Crea o reemplaza un recurso especifico. Si se crea un nuevo recurso, devuelve un 201 (CREATED), pero si actualiza un recurso existente, devuelve un código 200 (OK) O 204 (NO CONTENT). En caso ocurra un problema con la actualización, es posible devolver un código 409 (CONFLICT). La solicitud debe especificar la URI del recurso y el cuerpo los detalles del recurso a modificar.\u003C/p>\n\u003Cp>\u003Cstrong>PATCH\u003C/strong>: Actualiza parcialmente un recurso específico. A pesar que la especificación del método PUT no indica un formato correcto para este tipo de solicitudes, uno bastante común es que en el cuerpo de la petición, la información parche tiene el misma estructura del recurso original, sin embargo, solo incluye un subconjunto de campos que deben ser actualizados.\u003C/p>\n\u003Cp>\u003Cstrong>DELETE\u003C/strong>: Elimina un recurso especificado. Cuando la eliminación se realiza de manera correcta el servidor debe devolver un código de estado 204 (NO CONTENT), indicando que el proceso ha sido exitoso, pero sin contenido en el cuerpo de la respuesta. Si el recurso a eliminar no existe, se pude devolver un 404 (NOT FOUND).\u003C/p>\n\u003Cp>Siempre que el cuerpo de una respuesta correcta esté vacío, el código de estado podrá ser un 204 (NO CONTENT), como por ejemplo en una búsqueda de la cual no se encuentran resultados.\u003C/p>\n\u003Cp>Además de los métodos mencionados, el protocolo HTTP especifica que los formatos de datos se especifican mediante el uso de tipos de medio, conocidos como MIME types. Para daros no binarios, por lo general se emplea JSON (media type = \u003Ccode>aplication/json\u003C/code>), y esta información se debe incluir en el encabezado \u003Ccode>Content-Type\u003C/code> tanto de la solicitud como de la respuesta, lo cual indica el formato de la representación. Si el servidor recibe un MIME type que no se puede admitir, debe devolver un código de respuesta 415 (UNSUPPORTED MEDIA TYPE).\u003C/p>\n\u003Ch3 id=\"navegación-entre-recursos\">Navegación entre recursos\u003C/h3>\n\u003Cp>La filosofía REST establece que es posible navegar por todos los recursos de una API sin necesidad de conocer previamente su estructura o esquema. Para lograrlo, cada respuesta a una solicitud, como un \u003Cstrong>GET\u003C/strong>, debe incluir toda la información necesaria para que el cliente pueda descubrir y acceder a los recursos relacionados. Esto se logra mediante la inclusión de \u003Cstrong>hipervínculos\u003C/strong> dentro de la representación de los recursos, así como las operaciones disponibles para interactuar con ellos.\u003C/p>\n\u003Cp>Este principio fundamental se denomina \u003Cstrong>HATEOAS\u003C/strong> (Hypertext as the Engine of Application State) y garantiza que la interacción con la API sea autodescriptiva y dinámica. En otras palabras, el cliente puede explorar y consumir los recursos siguiendo los enlaces proporcionados, sin requerir conocimientos adicionales más allá del punto de entrada inicial.\u003C/p>\n\u003Cp>Por ejemplo, al solicitar información sobre un recurso específico, como un usuario, la respuesta podría incluir enlaces relacionados para acceder a otros recursos como los pedidos realizados por ese usuario o su perfil completo. Además, estos hipervínculos podrían especificar las acciones permitidas, como editar, eliminar o añadir un nuevo recurso.\u003C/p>\n\u003Cp>Este enfoque mejora la escalabilidad y la flexibilidad de las APIs RESTful, ya que facilita la evolución de la API y minimiza la dependencia del cliente en cambios de implementación específicos.\u003C/p>\n\u003Ch3 id=\"referencias\">Referencias\u003C/h3>\n\u003Cblockquote>\n\u003Col>\n\u003Cli>\u003Ca href=\"https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design\">https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://medium.com/@bourgeoistomas/nested-entities-in-your-api-rest-response-best-practices-and-trade-offs-81260ec49b90\">https://medium.com/@bourgeoistomas/nested-entities-in-your-api-rest-response-best-practices-and-trade-offs-81260ec49b90\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://stackoverflow.com/questions/20951419/what-are-best-practices-for-rest-nested-resources\">https://stackoverflow.com/questions/20951419/what-are-best-practices-for-rest-nested-resources\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.moesif.com/blog/api-guide/getting-started-with-apis/#core-principles-of-restful-api\">https://www.moesif.com/blog/api-guide/getting-started-with-apis/#core-principles-of-restful-api\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Sub-and-Nested-Resources/\">https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Sub-and-Nested-Resources/\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://martinfowler.com/articles/richardsonMaturityModel.html\">https://martinfowler.com/articles/richardsonMaturityModel.html\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://github.com/microsoft/api-guidelines/blob/vNext/graph/articles/collections.md\">https://github.com/microsoft/api-guidelines/blob/vNext/graph/articles/collections.md\u003C/a>\u003C/li>\n\u003C/ol>\n\u003C/blockquote>",{"headings":24,"imagePaths":61,"frontmatter":62},[25,29,33,36,39,42,46,49,52,55,58],{"depth":26,"slug":27,"text":28},4,"modelo-de-madurez-de-las-api-rest","Modelo de madurez de las API REST",{"depth":30,"slug":31,"text":32},3,"recursos","Recursos",{"depth":30,"slug":34,"text":35},"endpoints-anidados","Endpoints anidados",{"depth":30,"slug":37,"text":38},"carga-y-diseño","Carga y diseño",{"depth":30,"slug":40,"text":41},"entidades-anidadas","Entidades anidadas",{"depth":43,"slug":44,"text":45},5,"incluir-las-relaciones-en-las-respuestas","Incluir las relaciones en las respuestas",{"depth":43,"slug":47,"text":48},"incluir-información-parcial","Incluir información parcial",{"depth":43,"slug":50,"text":51},"entidades-poco-profundas","Entidades poco profundas",{"depth":30,"slug":53,"text":54},"semántica-http","Semántica HTTP",{"depth":30,"slug":56,"text":57},"navegación-entre-recursos","Navegación entre recursos",{"depth":30,"slug":59,"text":60},"referencias","Referencias",[],{"title":14,"description":15,"pubDate":63,"heroImage":17},"Feb 04 2025"]